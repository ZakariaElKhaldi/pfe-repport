\chapter*{Chapitre 3 : Réalisation et mise en œuvre des systèmes}
\addcontentsline{toc}{chapter}{Chapitre 3 : Réalisation et mise en œuvre des systèmes}
\thispagestyle{fancy}
\setcounter{section}{0}
\newpage

\section{Introduction}

Ce troisième chapitre aborde la phase concrète de réalisation et de mise en œuvre des deux systèmes développés dans le cadre de ce projet : le système de gestion scolaire et la plateforme de création de profils IA. Nous y détaillons les outils et technologies utilisés, les différentes étapes d'implémentation, ainsi que les interfaces utilisateur développées pour chaque type d'utilisateur. Cette phase de réalisation représente la concrétisation des concepts et architectures définis dans les chapitres précédents, transformant les spécifications et les modèles en solutions fonctionnelles. Nous mettons également en évidence les défis techniques rencontrés et les solutions apportées tout au long du processus de développement.

\section{Outils et technologies de développement}
Pour la réalisation de nos deux systèmes dont l'architecture a été détaillée dans le chapitre précédent, nous avons sélectionné un ensemble d'outils et de technologies modernes qui répondent aux exigences établies dans le cahier des charges.

\subsection{Environnement de développement}
L'environnement de développement a été configuré avec soin pour assurer une productivité optimale et une collaboration efficace :

\begin{itemize}
  \item \textbf{Visual Studio Code} : Comme éditeur de code principal avec des extensions pour TypeScript, React, Python et ESLint
  
  \item \textbf{Git et GitHub} : Pour la gestion de versions et la collaboration entre les membres de l'équipe
  
  \item \textbf{Docker} : Pour la conteneurisation des services et la cohérence des environnements de développement
  
  \item \textbf{Postman} : Pour tester et documenter les API REST
  
  \item \textbf{Chrome DevTools} : Pour le débogage et l'optimisation des performances frontend
  
  \item \textbf{MongoDB Compass et pgAdmin} : Pour la gestion visuelle des bases de données
\end{itemize}

\subsection{Technologies frontend}
Pour le développement des interfaces utilisateur, nous avons adopté des technologies modernes et performantes :

\subsubsection{Système de gestion scolaire}

\begin{itemize}
  \item \textbf{React 19} : Bibliothèque JavaScript pour la construction d'interfaces utilisateur réactives
  
  \item \textbf{TypeScript} : Langage typé apportant robustesse et maintenabilité au code
  
  \item \textbf{Vite} : Outil de build rapide pour le développement et la production
  
  \item \textbf{Tailwind CSS} : Framework CSS utilitaire pour un design responsive et personnalisable
  
  \item \textbf{React Router} : Pour la gestion du routage et de la navigation
  
  \item \textbf{React Hook Form} : Pour la gestion efficace des formulaires avec validation
  
  \item \textbf{Radix UI} : Composants UI accessibles et personnalisables
  
  \item \textbf{React Query} : Pour la gestion optimisée des requêtes API et du cache
  
  \item \textbf{React Native} : Pour le développement des applications mobiles multiplateformes
  
  \item \textbf{Expo} : Plateforme simplifiant le développement React Native
\end{itemize}

\subsubsection{Système de création de profils IA}

\begin{itemize}
  \item \textbf{React} : Pour la construction de l'interface utilisateur
  
  \item \textbf{TypeScript} : Pour un code plus robuste et maintenable
  
  \item \textbf{Chakra UI} : Bibliothèque de composants accessibles et esthétiques
  
  \item \textbf{Tailwind CSS} : Pour la stylisation efficace des composants
  
  \item \textbf{React Router} : Pour la navigation entre les différentes vues
  
  \item \textbf{React Query} : Pour la gestion optimisée des requêtes API
  
  \item \textbf{Framer Motion} : Pour les animations et transitions fluides
\end{itemize}

\subsection{Technologies backend}

Les backends de nos deux systèmes ont été développés avec des technologies adaptées à leurs besoins spécifiques :

\subsubsection{Système de gestion scolaire}

\begin{itemize}
  \item \textbf{Node.js} : Environnement d'exécution JavaScript côté serveur
  
  \item \textbf{Express} : Framework web minimaliste et flexible pour Node.js
  
  \item \textbf{TypeScript} : Pour un développement backend typé et robuste
  
  \item \textbf{MySQL} : Système de gestion de base de données relationnelle
  
  \item \textbf{Mongoose} : ODM pour l'intégration avec MongoDB (pour certaines fonctionnalités spécifiques)
  
  \item \textbf{JWT} : Pour l'authentification et la gestion des sessions
  
  \item \textbf{Multer} : Pour la gestion des uploads de fichiers
  
  \item \textbf{Socket.IO} : Pour les fonctionnalités en temps réel
  
  \item \textbf{Swagger} : Pour la documentation automatique des API
\end{itemize}

\subsubsection{Système de création de profils IA}

\begin{itemize}
  \item \textbf{FastAPI} : Framework Python moderne, performant et facile à utiliser
  
  \item \textbf{SQLAlchemy} : ORM Python pour l'interaction avec la base de données
  
  \item \textbf{Pydantic} : Pour la validation des données et la sérialisation
  
  \item \textbf{PostgreSQL} : Base de données relationnelle robuste
  
  \item \textbf{Alembic} : Pour les migrations de base de données
  
  \item \textbf{PyPDF2, python-docx} : Pour le traitement des documents
  
  \item \textbf{OpenAI API} : Pour l'intégration avec les modèles de langage
  
  \item \textbf{Redis} : Pour la mise en cache et la limitation de débit
  
  \item \textbf{Supabase} : Pour l'authentification et le stockage de fichiers
\end{itemize}

\subsection{Outils de déploiement et d'intégration continue}

Pour assurer un processus de développement fluide et des déploiements fiables :

\begin{itemize}
  \item \textbf{Docker et Docker Compose} : Pour la conteneurisation et l'orchestration des services
  
  \item \textbf{GitHub Actions} : Pour l'automatisation des tests et des déploiements
  
  \item \textbf{Nginx} : Comme serveur web et reverse proxy
  
  \item \textbf{PM2} : Pour la gestion des processus Node.js en production
  
  \item \textbf{Gunicorn} : Serveur WSGI pour les applications Python
\end{itemize}

\section{Développement du système de gestion scolaire}

\subsection{Implémentation du backend}
Le développement du backend du système de gestion scolaire a suivi une approche structurée basée sur l'architecture en couches :

\begin{itemize}
  \item \textbf{Structure du projet} : Organisation en modules fonctionnels (utilisateurs, cours, présences, notes, etc.)
  
  \item \textbf{API RESTful} : Conception d'endpoints suivant les bonnes pratiques REST avec des routes clairement définies
  
  \item \textbf{Middleware d'authentification} : Implémentation d'un système robuste basé sur JWT avec différents niveaux d'autorisation
  
  \item \textbf{Validation des données} : Utilisation d'express-validator pour garantir l'intégrité des données entrantes
  
  \item \textbf{Gestion des erreurs} : Mise en place d'un système centralisé de gestion des exceptions
  
  \item \textbf{Documentation API} : Intégration de Swagger pour une documentation interactive et toujours à jour
\end{itemize}

Le code suivant illustre la structure d'un contrôleur typique pour la gestion des cours :

\begin{lstlisting}[style=codestyle, language=JavaScript]
// src/controllers/courseController.ts
import { Request, Response } from 'express';
import { CourseService } from '../services/courseService';
import { handleError } from '../utils/errorHandler';

export class CourseController {
  private courseService: CourseService;
  
  constructor() {
    this.courseService = new CourseService();
  }
  
  public async createCourse(req: Request, res: Response): Promise<void> {
    try {
      const courseData = req.body;
      const teacherId = req.user.id; // From JWT token
      const course = await this.courseService.createCourse(courseData, teacherId);
      res.status(201).json({ success: true, data: course });
    } catch (error) {
      handleError(error, res);
    }
  }
  // Other methods...
}
\end{lstlisting}

\subsection{Développement des interfaces web}

Le développement des interfaces web a été réalisé avec une attention particulière à l'expérience utilisateur, en créant des interfaces adaptées à chaque type d'utilisateur du système.

\subsubsection{Interface administrateur}

L'interface administrateur offre une vue complète du système avec des fonctionnalités de gestion avancées :

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/admin/Screenshot 2025-06-09 at 22-38-06 Vite React TS.png}
  \caption{\textbf{Tableau de bord administrateur} présentant une vue d'ensemble des métriques du système.}
  \label{fig:admin_dashboard}
\end{figure}

Les principales fonctionnalités développées pour l'administrateur comprennent :

\begin{itemize}
  \item \textbf{Tableau de bord analytique} : Visualisation des statistiques clés de l'établissement
  
  \item \textbf{Gestion des utilisateurs} : Interface complète pour créer, modifier et gérer les comptes
  
  \item \textbf{Configuration du système} : Paramètres généraux et personnalisation
  
  \item \textbf{Gestion des cours} : Supervision de tous les cours et programmes
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/admin/Screenshot 2025-06-09 at 22-39-15 Vite React TS.png}
  \caption{\textbf{Interface de gestion des utilisateurs} permettant d'administrer les différents types de comptes.}
  \label{fig:user_management}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/admin/Screenshot 2025-06-09 at 22-40-11 Vite React TS.png}
  \caption{\textbf{Interface de gestion des cours} avec options de filtrage et d'organisation.}
  \label{fig:course_management_admin}
\end{figure}

\subsubsection{Interface enseignant}

L'interface enseignant a été conçue pour faciliter la gestion pédagogique et le suivi des étudiants :

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/teacher/Screenshot 2025-06-09 at 22-51-23 Vite React TS.png}
  \caption{\textbf{Tableau de bord enseignant} avec vue d'ensemble des cours et activités récentes.}
  \label{fig:teacher_dashboard}
\end{figure}

Les fonctionnalités clés développées pour les enseignants incluent :

\begin{itemize}
  \item \textbf{Gestion des cours} : Création et organisation du contenu pédagogique
  
  \item \textbf{Suivi des présences} : Interface intuitive pour l'enregistrement des présences
  
  \item \textbf{Évaluation} : Système complet pour la création, notation et commentaire des travaux
  
  \item \textbf{Communication} : Outils pour interagir avec les étudiants et les parents
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/teacher/Screenshot 2025-06-09 at 22-53-59 Vite React TS.png}
  \caption{\textbf{Interface de prise de présence} permettant un enregistrement rapide et efficace.}
  \label{fig:attendance_taking}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/teacher/Screenshot 2025-06-09 at 22-55-38 Vite React TS.png}
  \caption{\textbf{Interface de notation} avec options de feedback détaillé pour les étudiants.}
  \label{fig:grading_interface}
\end{figure}

\subsubsection{Interface étudiant}

L'interface étudiant a été développée pour offrir un accès clair aux cours, devoirs et résultats :

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/student/Screenshot 2025-06-09 at 22-43-56 Vite React TS.png}
  \caption{\textbf{Tableau de bord étudiant} présentant les cours, devoirs à venir et notifications.}
  \label{fig:student_dashboard}
\end{figure}

Les principales fonctionnalités pour les étudiants comprennent :

\begin{itemize}
  \item \textbf{Vue d'ensemble des cours} : Accès rapide aux cours suivis et leur contenu
  
  \item \textbf{Calendrier et échéances} : Organisation claire des devoirs et examens à venir
  
  \item \textbf{Soumission de travaux} : Interface intuitive pour déposer les devoirs
  
  \item \textbf{Consultation des résultats} : Visualisation des notes et commentaires des enseignants
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/student/Screenshot 2025-06-09 at 22-45-09 Vite React TS.png}
  \caption{\textbf{Interface de cours} avec accès au matériel pédagogique et aux ressources.}
  \label{fig:course_view}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/student/Screenshot 2025-06-09 at 22-46-22 Vite React TS.png}
  \caption{\textbf{Interface de soumission de devoir} avec options d'upload de fichiers.}
  \label{fig:assignment_submission}
\end{figure}

\subsubsection{Interface parent}

L'interface parent permet de suivre efficacement la progression académique des enfants :

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/parent/Screenshot 2025-06-09 at 22-57-22 Vite React TS.png}
  \caption{\textbf{Tableau de bord parent} avec vue d'ensemble des enfants et leurs activités scolaires.}
  \label{fig:parent_dashboard}
\end{figure}

Les fonctionnalités développées pour les parents incluent :

\begin{itemize}
  \item \textbf{Suivi multi-enfants} : Possibilité de suivre plusieurs enfants depuis un seul compte
  
  \item \textbf{Consultation des résultats} : Accès aux notes et évaluations
  
  \item \textbf{Suivi des présences} : Visualisation de l'assiduité de l'enfant
  
  \item \textbf{Communication} : Messagerie directe avec les enseignants et l'administration
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/parent/Screenshot 2025-06-09 at 22-58-13 Vite React TS.png}
  \caption{\textbf{Interface de suivi des résultats} permettant aux parents de visualiser les performances académiques.}
  \label{fig:grades_view}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/parent/Screenshot 2025-06-09 at 22-59-25 Vite React TS.png}
  \caption{\textbf{Interface de messagerie} pour la communication avec les enseignants.}
  \label{fig:messaging_interface}
\end{figure}

\subsubsection{Système d'authentification}

Un système d'authentification robuste a été implémenté pour sécuriser l'accès à la plateforme :

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth,keepaspectratio]{pfe-pics/auth/Screenshot 2025-06-09 at 23-00-18 Vite React TS.png}
  \caption{\textbf{Page de connexion} avec sélection du type d'utilisateur.}
  \label{fig:login_page}
\end{figure}

Les fonctionnalités d'authentification comprennent :

\begin{itemize}
  \item \textbf{Connexion sécurisée} : Authentification avec email et mot de passe
  
  \item \textbf{Récupération de mot de passe} : Procédure sécurisée de réinitialisation
  
  \item \textbf{Vérification d'email} : Confirmation de l'adresse email lors de l'inscription
  
  \item \textbf{Protection des routes} : Accès contrôlé aux différentes sections selon le rôle
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth,keepaspectratio]{pfe-pics/auth/Screenshot 2025-06-09 at 23-02-10 Vite React TS.png}
  \caption{\textbf{Interface de récupération de mot de passe} avec vérification par email.}
  \label{fig:password_reset}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/auth/Screenshot 2025-06-09 at 23-08-41 Reset Your Password - School Management System - vertigoevilman1@gmail.com - Gmail.png}
  \caption{\textbf{Email de réinitialisation de mot de passe} envoyé aux utilisateurs.}
  \label{fig:password_reset_email}
\end{figure}

\subsection{Développement des applications mobiles}

\subsubsection{Architecture de l'application mobile}

L'application mobile a été développée avec React Native et Expo pour offrir une expérience utilisateur native sur iOS et Android tout en partageant une base de code commune. L'architecture adoptée suit le modèle de composants React avec une gestion d'état centralisée.

\begin{itemize}
  \item \textbf{Structure du projet} : Organisation en modules fonctionnels avec séparation des préoccupations
  
  \item \textbf{Navigation} : Utilisation de React Navigation pour une expérience de navigation fluide
  
  \item \textbf{Gestion d'état} : Combinaison de Context API et de React Query pour la gestion des données
  
  \item \textbf{Composants réutilisables} : Bibliothèque de composants partagés entre les différentes vues
  
  \item \textbf{Adaptation responsive} : Interfaces s'adaptant aux différentes tailles d'écran
\end{itemize}

\subsubsection{Interfaces mobiles pour les étudiants}

L'application mobile offre aux étudiants un accès optimisé à leurs cours et activités :

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth,keepaspectratio]{pfe-pics/Mobile /Students/Screenshot_20250610_130022_Expo Go.jpg}
  \includegraphics[width=0.4\textwidth,keepaspectratio]{pfe-pics/Mobile /Students/Screenshot_20250610_130124_Expo Go.jpg}
  \caption{\textbf{Écrans d'accueil et de cours} de l'application mobile pour les étudiants.}
  \label{fig:mobile_student_home}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth,keepaspectratio]{pfe-pics/Mobile /Students/Screenshot_20250610_130150_Expo Go.jpg}
  \includegraphics[width=0.4\textwidth,keepaspectratio]{pfe-pics/Mobile /Students/Screenshot_20250610_130310_Expo Go.jpg}
  \caption{\textbf{Interfaces de consultation des devoirs et résultats} sur mobile.}
  \label{fig:mobile_student_assignments}
\end{figure}

\subsubsection{Interfaces mobiles pour les enseignants}

Les enseignants bénéficient d'une application mobile adaptée à leurs besoins spécifiques :

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth,keepaspectratio]{pfe-pics/Mobile /Teacher/Screenshot_20250610_130952_Expo Go.jpg}
  \includegraphics[width=0.4\textwidth,keepaspectratio]{pfe-pics/Mobile /Teacher/Screenshot_20250610_131009_Expo Go.jpg}
  \caption{\textbf{Tableau de bord et liste des cours} sur l'application mobile enseignant.}
  \label{fig:mobile_teacher_dashboard}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth,keepaspectratio]{pfe-pics/Mobile /Teacher/Screenshot_20250610_131112_Expo Go.jpg}
  \includegraphics[width=0.4\textwidth,keepaspectratio]{pfe-pics/Mobile /Teacher/Screenshot_20250610_131132_Expo Go.jpg}
  \caption{\textbf{Interfaces de prise de présence et de notation} optimisées pour mobile.}
  \label{fig:mobile_teacher_attendance}
\end{figure}

\subsubsection{Interfaces mobiles pour les parents}

L'application mobile pour les parents facilite le suivi des activités scolaires de leurs enfants :

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth,keepaspectratio]{pfe-pics/Mobile /Parent /Screenshot_20250610_132939_Expo Go.jpg}
  \includegraphics[width=0.4\textwidth,keepaspectratio]{pfe-pics/Mobile /Parent /Screenshot_20250610_133022_Expo Go.jpg}
  \caption{\textbf{Tableau de bord et sélection d'enfant} sur l'application mobile parent.}
  \label{fig:mobile_parent_dashboard}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth,keepaspectratio]{pfe-pics/Mobile /Parent /Screenshot_20250610_133032_Expo Go.jpg}
  \includegraphics[width=0.4\textwidth,keepaspectratio]{pfe-pics/Mobile /Parent /Screenshot_20250610_133047_Expo Go.jpg}
  \caption{\textbf{Suivi des résultats et des présences} sur mobile pour les parents.}
  \label{fig:mobile_parent_monitoring}
\end{figure}

\subsubsection{Authentification mobile}

Le système d'authentification mobile offre une expérience sécurisée et conviviale :

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth,keepaspectratio]{pfe-pics/Mobile /Auth/Screenshot_20250610_145348_Expo Go.jpg}
  \includegraphics[width=0.4\textwidth,keepaspectratio]{pfe-pics/Mobile /Auth/Screenshot_20250610_145354_Expo Go.jpg}
  \caption{\textbf{Écrans de connexion et d'inscription} sur l'application mobile.}
  \label{fig:mobile_auth_screens}
\end{figure}

\section{Développement du système de création de profils IA}

Le développement du système de création de profils IA a représenté un défi technique particulier, combinant traitement de documents, intelligence artificielle et interfaces utilisateur intuitives.

\subsection{Implémentation du backend}

Le backend du système de création de profils IA a été développé avec FastAPI, un framework Python moderne offrant d'excellentes performances et une documentation automatique :

\begin{itemize}
  \item \textbf{Architecture API-first} : Conception d'une API RESTful complète comme fondation du système
  
  \item \textbf{Modèle de données} : Utilisation de Pydantic pour la validation et la sérialisation des données
  
  \item \textbf{Gestion asynchrone} : Implémentation d'opérations asynchrones pour optimiser les performances
  
  \item \textbf{Intégration avec OpenAI} : Connexion sécurisée avec l'API OpenAI via OpenRouter pour l'accès aux modèles de langage
  
  \item \textbf{Stockage hybride} : Combinaison de PostgreSQL pour les métadonnées et de stockage objet pour les documents
\end{itemize}

Voici un exemple de structure d'endpoint FastAPI pour la création d'un profil IA :

\begin{lstlisting}[style=codestyle, language=Python]
# app/routers/profiles.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List
from app.schemas.profile import ProfileCreate, ProfileResponse
from app.services.profile_service import ProfileService
from app.dependencies import get_db, get_current_user
from app.models.user import User

router = APIRouter(prefix="/profiles", tags=["profiles"])

@router.post("/", response_model=ProfileResponse, status_code=status.HTTP_201_CREATED)
async def create_profile(
    profile_data: ProfileCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    profile_service = ProfileService(db)
    return await profile_service.create_profile(profile_data, current_user.id)
# Additional endpoints...
\end{lstlisting}

\subsubsection{Documentation des API et exemples d'utilisation}

Les deux systèmes exposent des API RESTful pour permettre l'intégration avec d'autres applications. Voici une documentation détaillée des principaux endpoints avec des exemples d'utilisation.

\paragraph{API du système de gestion scolaire}

\begin{table}[H]
\centering
\begin{tabular}{|p{3.5cm}|p{2cm}|p{8.5cm}|}
\hline
\textbf{Endpoint} & \textbf{Méthode} & \textbf{Description} \\
\hline
/api/auth/login & POST & Authentification utilisateur et génération de token JWT \\
\hline
/api/auth/verify & GET & Vérification de la validité du token JWT \\
\hline
/api/users & GET, POST & Récupération et création d'utilisateurs \\
\hline
/api/users/:id & GET, PUT, DELETE & Opérations sur un utilisateur spécifique \\
\hline
/api/courses & GET, POST & Récupération et création de cours \\
\hline
/api/courses/:id & GET, PUT, DELETE & Opérations sur un cours spécifique \\
\hline
/api/attendance & GET, POST & Récupération et enregistrement des présences \\
\hline
/api/grades & GET, POST & Récupération et enregistrement des notes \\
\hline
/api/documents & GET, POST & Gestion des documents pédagogiques \\
\hline
/api/profiles/\\integrate/:courseId & POST & Intégration d'un profil IA à un cours \\
\hline
\end{tabular}
\caption{Principaux endpoints de l'API du système de gestion scolaire}
\label{tab:school_api_endpoints}
\end{table}

\paragraph{Exemple d'authentification avec curl}

\begin{lstlisting}[style=codestyle, language=bash]
# Authentification et récupération du token JWT
curl -X POST http://localhost:3001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email": "teacher@school.com", "password": "password123"}'

# Réponse
{
  "success": true,
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "user": { "id": "t123", "role": "teacher", "name": "John Doe" }
  }
}
\end{lstlisting}

\paragraph{Exemple de création d'un cours avec curl}

\begin{lstlisting}[style=codestyle, language=bash]
# Création d'un nouveau cours
curl -X POST http://localhost:3001/api/courses \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." \
  -d '{
    "name": "Introduction à la programmation",
    "description": "Fondamentaux de la programmation en Python",
    "startDate": "2025-09-15",
    "endDate": "2026-01-30"
  }'

# Réponse (version simplifiée)
{
  "success": true,
  "data": {
    "id": "c456",
    "name": "Introduction à la programmation",
    "teacherId": "t123"
    // Autres champs omis pour concision
  }
}
\end{lstlisting}

\paragraph{API du système de création de profils IA}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|p{4.5cm}|p{2cm}|p{7.5cm}|}
\hline
\textbf{Endpoint} & \textbf{Méthode} & \textbf{Description} \\
\hline
/api/auth/token & POST & Authentification et génération de token JWT \\
\hline
/api/profiles & GET, POST & Récupération et création de profils IA \\
\hline
/api/profiles/:id & GET, PUT, DELETE & Opérations sur un profil spécifique \\
\hline
/api/documents & POST & Upload de documents pour l'entraînement \\
\hline
/api/documents/:id & GET, DELETE & Opérations sur un document spécifique \\
\hline
/api/profiles/:id/chat & POST & Conversation avec un profil IA \\
\hline
/api/profiles/:id/train & POST & Démarrage d'un entraînement sur de nouveaux documents \\
\hline
/api/profiles/:id/keys & GET, POST & Gestion des clés API pour un profil \\
\hline
/api/openrouter/models & GET & Liste des modèles disponibles via OpenRouter \\
\hline
/api/health & GET & Vérification de l'état du système \\
\hline
\end{tabular}
\caption{Principaux endpoints de l'API du système de création de profils IA}
\label{tab:ai_api_endpoints}
\end{table}

\paragraph{Exemple d'interaction avec un profil IA}

\begin{lstlisting}[style=codestyle, language=bash]
# Envoi d'une question à un profil IA
curl -X POST http://localhost:8000/api/profiles/p789/chat \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." \
  -d '{
    "message": "Quelle est la différence entre une classe et un objet en POO?",
    "context": { "courseId": "c456" }
  }'

# Réponse simplifiée
{
  "id": "msg123",
  "content": "Une classe est un modèle qui définit la structure et le comportement. Un objet est une instance concrète d'une classe qui occupe de l'espace mémoire.",
  "sources": [{ "document_name": "Introduction_POO.pdf", "page": 12 }]
}
\end{lstlisting}

\paragraph{Exemple de création d'une clé API pour un profil}

\begin{lstlisting}[style=codestyle, language=bash]
# Création d'une clé API pour un profil spécifique
curl -X POST http://localhost:8000/api/profiles/p789/keys \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." \
  -d '{
    "name": "Integration Moodle",
    "expires_in_days": 90,
    "permissions": ["read", "chat"]
  }'

# Réponse
{
  "key_id": "key123",
  "api_key": "pfeia_789xyz123abc456def",
  "name": "Integration Moodle",
  "permissions": ["read", "chat"],
  "created_at": "2025-06-10T16:00:35Z",
  "expires_at": "2025-09-08T16:00:35Z"
}
\end{lstlisting}

\paragraph{Intégration des systèmes via API}

L'exemple suivant montre comment le système de gestion scolaire peut interagir avec le système de profils IA :

\begin{lstlisting}[style=codestyle, language=JavaScript]
// Dans le backend du système de gestion scolaire
// services/aiProfileService.js

const axios = require('axios');
const config = require('../config');

class AIProfileService {
  constructor() {
    this.apiClient = axios.create({
      baseURL: config.AI_PROFILES_API_URL,
      timeout: 10000
    });
  }

  // Associe un profil IA à un cours spécifique
  async linkProfileToCourse(profileId, courseId, token) {
    try {
      const response = await this.apiClient.post(
        `/api/integration/link`,
        {
          profileId,
          courseId,
          settings: { visibleToStudents: true, allowQuestions: true }
        },
        { headers: { Authorization: `Bearer ${token}` } }
      );
      return response.data;
    } catch (error) {
      console.error('Erreur lors de la liaison du profil:', error);
      throw error;
    }
  }
  // Autres méthodes...
}
\end{lstlisting}

\subsection{Développement de l'interface utilisateur}

L'interface utilisateur du système de création de profils IA a été conçue pour être intuitive et efficace, permettant aux utilisateurs de créer et gérer facilement leurs profils IA :

\subsubsection{Page d'accueil et tableau de bord}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/ai-profile-creation/dashboared_befor_adding_a_new_ai_profile.png}
  \caption{\textbf{Tableau de bord} du système de création de profils IA avant l'ajout d'un nouveau profil.}
  \label{fig:ai_dashboard}
\end{figure}

Le tableau de bord offre une vue d'ensemble des profils créés par l'utilisateur, avec des métriques clés comme :

\begin{itemize}
  \item Nombre de profils actifs
  \item Statistiques d'utilisation récente
  \item État de traitement des documents
  \item Accès rapide aux profils favoris
\end{itemize}

\subsubsection{Création et configuration de profil}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/ai-profile-creation/creating_and_ai_prifile.png}
  \caption{\textbf{Interface de création de profil IA} avec options de configuration.}
  \label{fig:profile_creation}
\end{figure}

L'interface de création de profil permet aux utilisateurs de :

\begin{itemize}
  \item Définir les informations de base du profil (nom, description, domaine)
  \item Configurer le comportement de l'IA (ton, style de réponse, niveau de détail)
  \item Sélectionner des catégories et tags pour organiser les profils
  \item Définir les paramètres de confidentialité et d'accès
\end{itemize}

\subsubsection{Upload et gestion des documents}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/ai-profile-creation/see_upladed_documents_knoladge.png}
  \caption{\textbf{Interface de visualisation des documents uploadés} et leur connaissance associée.}
  \label{fig:document_knowledge}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/ai-profile-creation/extract_info_from_file_and_training_pfrile.png}
  \caption{\textbf{Interface d'extraction d'information} à partir des fichiers et entrainement du profil.}
  \label{fig:document_extraction}
\end{figure}

L'interface de gestion des documents offre des fonctionnalités avancées :

\begin{itemize}
  \item Upload par glisser-déposer de multiples formats (PDF, DOCX, TXT)
  \item Visualisation de l'état de traitement en temps réel
  \item Organisation des documents par catégories
  \item Prévisualisation du contenu extrait
  \item Possibilité d'ajouter des métadonnées et annotations
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/ai-profile-creation/succesful_knoladge_integration.png}
  \caption{\textbf{Confirmation d'intégration réussie} des connaissances extraites dans le profil IA.}
  \label{fig:knowledge_integration}
\end{figure}

\subsubsection{Interface de test et conversation}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/ai-profile-creation/chat_interface_to_test_the_profile.png}
  \caption{\textbf{Interface de conversation pour tester le profil IA} créé.}
  \label{fig:profile_testing}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/ai-profile-creation/chat_interface_for_testing_profile_2_test_prompt_succes.png}
  \caption{\textbf{Résultat réussi de test du profil} avec des prompts de vérification.}
  \label{fig:profile_test_success}
\end{figure}

L'interface de conversation permet une interaction naturelle avec les profils IA :

\begin{itemize}
  \item Design inspiré des applications de messagerie modernes
  \item Historique des conversations sauvegardé
  \item Affichage des sources documentaires pour les réponses
  \item Options de feedback pour améliorer les réponses
  \item Possibilité de partager des conversations
\end{itemize}

\subsubsection{Gestion des API et intégrations}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/ai-profile-creation/create_and_api_key_for_trained_profile.png}
  \caption{\textbf{Interface de création de clé API} pour un profil IA entrainé.}
  \label{fig:api_key_creation}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/ai-profile-creation/adding_openRouter_api.png}
  \caption{\textbf{Interface d'ajout d'une clé API OpenRouter} pour l'accès aux modèles de langage.}
  \label{fig:openrouter_api_addition}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/ai-profile-creation/oneRouter_keys_hestory.png}
  \caption{\textbf{Historique des clés API OpenRouter} utilisées par le système.}
  \label{fig:api_keys_history}
\end{figure}

Pour les utilisateurs souhaitant intégrer leurs profils IA dans d'autres applications :

\begin{itemize}
  \item Création et gestion de clés API avec permissions spécifiques
  \item Documentation interactive des endpoints disponibles
  \item Exemples de code pour différents langages de programmation
  \item Suivi de l'utilisation et des quotas
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/ai-profile-creation/api_diagnostics.png}
  \caption{\textbf{Interface de diagnostics API} pour la vérification des problèmes d'intégration.}
  \label{fig:api_diagnostics}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/ai-profile-creation/test_openRouter_connection.png}
  \caption{\textbf{Test de connexion OpenRouter} pour vérifier la configuration du service.}
  \label{fig:openrouter_test}
\end{figure}

\subsection{Pipeline de traitement des documents}

Le cœur du système de création de profils IA réside dans son pipeline de traitement des documents, qui transforme les documents bruts en base de connaissances structurée pour l'IA.

\subsubsection{Architecture du pipeline}

Le pipeline de traitement a été conçu comme un système asynchrone à plusieurs étapes :

\begin{itemize}
  \item \textbf{Réception et validation} : Vérification des formats et de l'intégrité des documents
  
  \item \textbf{Extraction de texte} : Conversion des différents formats en texte brut
  
  \item \textbf{Analyse structurelle} : Identification des sections, titres et éléments spéciaux
  
  \item \textbf{Segmentation intelligente} : Découpage en chunks optimisés pour la recherche sémantique
  
  \item \textbf{Génération d'embeddings} : Création de représentations vectorielles pour chaque segment
  
  \item \textbf{Indexation} : Stockage optimisé pour la recherche rapide
\end{itemize}

\subsubsection{Optimisation du chunking}

Une attention particulière a été portée à l'optimisation de la segmentation des documents :

\begin{itemize}
  \item \textbf{Chunking sémantique} : Découpage respectant la structure logique du contenu
  
  \item \textbf{Chevauchement contrôlé} : Inclusion partielle du contexte entre segments adjacents
  
  \item \textbf{Métadonnées enrichies} : Association de chaque segment à sa position et son contexte
  
  \item \textbf{Traitement spécifique} : Gestion adaptée des tableaux, listes et éléments spéciaux
\end{itemize}

\subsubsection{Intégration avec les modèles LLM}

L'interaction avec les modèles de langage a été optimisée pour obtenir les meilleures performances :

\begin{itemize}
  \item \textbf{Sélection contextuelle} : Identification des segments les plus pertinents pour chaque requête
  
  \item \textbf{Construction de prompts} : Génération dynamique de prompts optimisés incluant le contexte documentaire
  
  \item \textbf{Gestion du contexte conversationnel} : Maintien de la cohérence dans les échanges multi-tours
  
  \item \textbf{Mécanismes de fallback} : Stratégies alternatives en cas d'absence d'information pertinente
\end{itemize}

\section{Intégration et tests}

\subsection{Mise en œuvre de l'intégration}

En nous basant sur l'architecture d'intégration définie dans le chapitre précédent, nous avons implémenté les mécanismes suivants pour faire communiquer nos deux systèmes :

\begin{itemize}
  \item \textbf{Configuration Nginx} : Mise en place d'un fichier de configuration Nginx agissant comme API Gateway :
\end{itemize}

\begin{lstlisting}[style=codestyle, language=bash]
# /etc/nginx/sites-available/education-platform.conf
server {
    listen 80;
    server_name education-platform.example.com;
    
    # Redirection vers HTTPS
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl;
    server_name education-platform.example.com;
    
    ssl_certificate /etc/ssl/certs/education-platform.crt;
    ssl_certificate_key /etc/ssl/private/education-platform.key;
    
    # Route vers le système de gestion scolaire
    location /school/ {
        proxy_pass http://school-management:3001/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    
    # Route vers le système de profils IA
    location /ai-profiles/ {
        proxy_pass http://ai-profiles:8000/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    
    # Gestion des websockets pour le chat
    location /ai-profiles/ws/ {
        proxy_pass http://ai-profiles:8000/ws/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
\end{lstlisting}

\begin{itemize}
  \item \textbf{Implémentation du middleware d'authentification partagée} : Pour permettre la navigation entre les deux systèmes avec un seul token :
\end{itemize}

\begin{lstlisting}[style=codestyle, language=JavaScript]
// middleware/sharedAuth.js
const jwt = require('jsonwebtoken');
const { SECRET_KEY } = require('../config');

const verifySharedToken = (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ message: 'Authentification requise' });
  }
  
  try {
    const decoded = jwt.verify(token, SECRET_KEY);
    req.user = decoded;
    
    // Ajouter des informations sur le système source
    req.user.source = 'school_management';
    
    next();
  } catch (error) {
    return res.status(401).json({ message: 'Token invalide' });
  }
};

module.exports = { verifySharedToken };
\end{lstlisting}

\begin{itemize}
  \item \textbf{Développement du service d'intégration des profils IA} : Implémentation côté système de gestion scolaire :
\end{itemize}

\begin{lstlisting}[style=codestyle, language=JavaScript]
// services/aiProfileIntegration.js
const axios = require('axios');
const config = require('../config');

class AIProfileIntegrationService {
  constructor() {
    this.apiClient = axios.create({
      baseURL: config.AI_PROFILES_API_URL,
      timeout: 10000
    });
  }

  async associateProfileWithCourse(profileId, courseId, token) {
    try {
      const response = await this.apiClient.post(
        '/integration/associate',
        {
          profileId,
          courseId,
          settings: {
            visibleToStudents: true,
            allowDirectQuestions: true
          }
        },
        {
          headers: {
            Authorization: `Bearer ${token}`
          }
        }
      );
      
      return response.data;
    } catch (error) {
      console.error('Error associating profile with course:', error);
      throw error;
    }
  }
  
  // Autres méthodes d'intégration...
}

module.exports = new AIProfileIntegrationService();
\end{lstlisting}

\subsection{Tests d'intégration}

Pour valider le bon fonctionnement de l'intégration entre nos deux systèmes, nous avons développé une suite de tests automatisés :

\begin{lstlisting}[style=codestyle, language=JavaScript]
// tests/integration/aiProfileIntegration.test.js
const request = require('supertest');
const app = require('../../app');
const mongoose = require('mongoose');
const { generateTestToken } = require('../utils/auth');

describe('AI Profile Integration', () => {
  let authToken;
  let testCourseId;
  
  beforeAll(async () => {
    // Setup: créer un utilisateur de test et un cours
    authToken = generateTestToken({ role: 'teacher' });
    
    const courseResponse = await request(app)
      .post('/api/courses')
      .set('Authorization', `Bearer ${authToken}`)
      .send({
        name: 'Test Integration Course',
        description: 'Course for integration testing'
      });
      
    testCourseId = courseResponse.body.data.id;
  });
  
  test('Should associate an AI profile with a course', async () => {
    const profileId = 'test-profile-123';
    
    const response = await request(app)
      .post(`/api/courses/${testCourseId}/ai-profiles`)
      .set('Authorization', `Bearer ${authToken}`)
      .send({ profileId });
      
    expect(response.status).toBe(200);
    expect(response.body.success).toBe(true);
    expect(response.body.data.courseId).toBe(testCourseId);
    expect(response.body.data.profileId).toBe(profileId);
  });
  
  // Autres tests d'intégration...
  
  afterAll(async () => {
    await mongoose.connection.close();
  });
});
\end{lstlisting}

\subsection{Validation de l'intégration}

Pour assurer la qualité de l'intégration, nous avons mis en place une approche de validation complète :

\begin{itemize}
  \item \textbf{Tests unitaires} : Vérification du comportement isolé des composants d'intégration
  
  \item \textbf{Tests d'intégration} : Validation des interactions entre les systèmes
  
  \item \textbf{Tests end-to-end} : Simulation de scénarios utilisateur complets traversant les deux systèmes
  
  \item \textbf{Tests de charge} : Évaluation des performances sous contrainte à l'aide de l'outil k6
\end{itemize}

Exemple de script de test de charge pour l'intégration :

\begin{lstlisting}[style=codestyle, language=JavaScript]
// tests/performance/integration-load.js (k6 script)
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  vus: 50,              // 50 utilisateurs virtuels
  duration: '2m',       // pendant 2 minutes
  thresholds: {
    http_req_duration: ['p(95)<500'],  // 95% des requêtes doivent répondre en moins de 500ms
    http_req_failed: ['rate<0.01'],    // moins de 1% d'erreurs
  },
};

export default function() {
  const BASE_URL = 'https://education-platform.example.com';
  const authToken = generateTestToken();  // fonction fictive
  
  // Tester la navigation entre les deux systèmes
  const schoolResponse = http.get(`${BASE_URL}/school/api/courses`, {
    headers: { Authorization: `Bearer ${authToken}` },
  });
  
  check(schoolResponse, {
    'school API status is 200': (r) => r.status === 200,
  });
  
  sleep(1);
  
  // Tester l'interaction avec un profil IA associé à un cours
  const aiResponse = http.post(`${BASE_URL}/ai-profiles/api/chat`, {
    headers: { Authorization: `Bearer ${authToken}` },
    payload: JSON.stringify({
      courseId: 'course-123',
      message: 'Tell me about object-oriented programming'
    }),
  });
  
  check(aiResponse, {
    'AI API status is 200': (r) => r.status === 200,
    'AI response contains content': (r) => JSON.parse(r.body).content !== undefined,
  });
  
  sleep(2);
}
\end{lstlisting}

\section{Déploiement et mise en production}

\subsection{Configuration de l'infrastructure de déploiement}

Pour le déploiement de nos systèmes, nous avons mis en place une infrastructure basée sur Docker et Docker Compose, avec le fichier de configuration suivant :

\begin{lstlisting}[style=codestyle, language=YAML]
# docker-compose.yml
version: '3.8'

services:
  # Service du système de gestion scolaire
  school-management:
    build: 
      context: ./school-management
      dockerfile: Dockerfile.production
    restart: always
    environment:
      - NODE_ENV=production
      - DATABASE_URL=mysql://user:password@mysql:3306/school_db
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      - mysql
    networks:
      - app-network

  # Service du système de profils IA
  ai-profiles:
    build:
      context: ./ai-profiles
      dockerfile: Dockerfile.production
    restart: always
    environment:
      - POSTGRES_DSN=postgresql://user:password@postgres:5432/ai_profiles_db
      - OPENROUTER_API_KEY=${OPENROUTER_API_KEY}
    depends_on:
      - postgres
      - redis
    networks:
      - app-network

  # Bases de données et cache
  mysql:
    image: mysql:8.0
    restart: always
    # Configuration omise pour concision
    networks:
      - app-network
  
  postgres:
    image: postgres:14
    restart: always
    # Configuration omise pour concision
    networks:
      - app-network

  redis:
    image: redis:7-alpine
    restart: always
    networks:
      - app-network

  # Serveur Nginx pour l'API Gateway
  nginx:
    image: nginx:1.23-alpine
    ports:
      - "80:80"
      - "443:443"
    # Configuration omise pour concision
    networks:
      - app-network

volumes:
  mysql-data:
  postgres-data:
  redis-data:

networks:
  app-network:
    driver: bridge
\end{lstlisting}

\subsection{Pipeline d'intégration et déploiement continus}

Nous avons configuré GitHub Actions pour automatiser l'intégration et le déploiement continus :

\begin{lstlisting}[style=codestyle, language=YAML]
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [school-management, ai-profiles]
    
    steps:
      - uses: actions/checkout@v3
      
      # Configuration Node.js ou Python selon le service
      - name: Set up Node.js
        if: matrix.service == 'school-management'
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Set up Python
        if: matrix.service == 'ai-profiles'
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      # Installation des dépendances et exécution des tests
      # Étapes omises pour concision

  build:
    name: Build
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      - name: Build and push Docker images
        # Configuration omise pour concision

  deploy:
    name: Deploy
    needs: build
    runs-on: ubuntu-latest
    
    steps:
      - name: Deploy to production
        # Déploiement via SSH
        # Configuration omise pour concision
\end{lstlisting}

\subsection{Stratégie de déploiement bleu-vert}

Pour permettre des mises à jour sans interruption de service, nous avons implémenté un script de déploiement bleu-vert :

\begin{lstlisting}[style=codestyle, language=bash]
#!/bin/bash
# deploy-blue-green.sh

set -e

# Définition des variables
DOCKER_REPO="our-org"
SERVICES=("school-management" "ai-profiles")
CURRENT_ENV=$(cat /opt/education-platform/current_env)
NEXT_ENV=""

# Déterminer l'environnement cible
if [ "$CURRENT_ENV" == "blue" ]; then
  NEXT_ENV="green"
else
  NEXT_ENV="blue"
fi

echo "Déploiement vers l'environnement $NEXT_ENV (actuel: $CURRENT_ENV)"

# Préparation du nouvel environnement
cd /opt/education-platform
cp docker-compose.${NEXT_ENV}.yml docker-compose.yml

# Mise à jour des images
docker-compose pull

# Démarrage du nouvel environnement
docker-compose up -d

# Vérification de la santé du nouvel environnement
for service in "${SERVICES[@]}"; do
  echo "Vérification de la santé de $service..."
  for i in {1..30}; do
    if curl -s "http://localhost:${NEXT_ENV}-health-check-port/$service/health" | grep -q "ok"; then
      echo "$service est prêt !"
      break
    fi
    
    if [ $i -eq 30 ]; then
      echo "Échec du déploiement : $service n'est pas sain après 30 tentatives"
      # Revenir à l'environnement précédent
      cp docker-compose.${CURRENT_ENV}.yml docker-compose.yml
      docker-compose up -d
      exit 1
    fi
    
    echo "En attente de $service... ($i/30)"
    sleep 2
  done
done

# Mise à jour du proxy Nginx pour rediriger le trafic
cp nginx/conf/upstream.${NEXT_ENV}.conf nginx/conf/upstream.conf
docker-compose restart nginx

# Mettre à jour l'environnement actuel
echo "$NEXT_ENV" > /opt/education-platform/current_env

echo "Déploiement vers $NEXT_ENV terminé avec succès"

# Arrêt de l'ancien environnement après un délai pour terminer les sessions en cours
sleep 60
docker-compose -f docker-compose.${CURRENT_ENV}.yml down

echo "Nettoyage de l'ancien environnement $CURRENT_ENV terminé"
\end{lstlisting}

\subsection{Monitoring et journalisation}

Pour surveiller nos applications en production, nous avons configuré Prometheus et Grafana :

\begin{lstlisting}[style=codestyle, language=YAML]
# docker-compose.monitoring.yml
version: '3.8'

services:
  prometheus:
    image: prom/prometheus:latest
    volumes:
      - ./monitoring/prometheus:/etc/prometheus
      - prometheus-data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
    ports:
      - "9090:9090"
    networks:
      - monitoring-network

  grafana:
    image: grafana/grafana:latest
    volumes:
      - ./monitoring/grafana/provisioning:/etc/grafana/provisioning
      - grafana-data:/var/lib/grafana
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
      - GF_USERS_ALLOW_SIGN_UP=false
    ports:
      - "3000:3000"
    depends_on:
      - prometheus
    networks:
      - monitoring-network

  node-exporter:
    image: prom/node-exporter:latest
    restart: always
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /:/rootfs:ro
    command:
      - '--path.procfs=/host/proc'
      - '--path.sysfs=/host/sys'
      - '--path.rootfs=/rootfs'
    ports:
      - "9100:9100"
    networks:
      - monitoring-network

volumes:
  prometheus-data:
  grafana-data:

networks:
  monitoring-network:
    driver: bridge
  app-network:
    external: true
\end{lstlisting}

Pour la journalisation centralisée, nous avons déployé ELK Stack (Elasticsearch, Logstash, Kibana) :

\begin{lstlisting}[style=codestyle, language=YAML]
# docker-compose.logging.yml
version: '3.8'

services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.17.0
    environment:
      - discovery.type=single-node
      - ES_JAVA_OPTS=-Xms512m -Xmx512m
    volumes:
      - elasticsearch-data:/usr/share/elasticsearch/data
    ports:
      - "9200:9200"
    networks:
      - logging-network

  logstash:
    image: docker.elastic.co/logstash/logstash:7.17.0
    volumes:
      - ./logging/logstash/pipeline:/usr/share/logstash/pipeline
    ports:
      - "5000:5000"
    depends_on:
      - elasticsearch
    networks:
      - logging-network
      - app-network

  kibana:
    image: docker.elastic.co/kibana/kibana:7.17.0
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
    ports:
      - "5601:5601"
    depends_on:
      - elasticsearch
    networks:
      - logging-network

  filebeat:
    image: docker.elastic.co/beats/filebeat:7.17.0
    user: root
    volumes:
      - ./logging/filebeat/filebeat.yml:/usr/share/filebeat/filebeat.yml:ro
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro
    depends_on:
      - elasticsearch
      - logstash
    networks:
      - logging-network
      - app-network

volumes:
  elasticsearch-data:

networks:
  logging-network:
    driver: bridge
  app-network:
    external: true
\end{lstlisting}

\subsection{Sauvegarde et récupération}

Pour assurer la sécurité des données, nous avons mis en place un script de sauvegarde automatique :

\begin{lstlisting}[style=codestyle, language=bash]
#!/bin/bash
# backup.sh

# Configuration
BACKUP_DIR="/opt/education-platform/backups"
MYSQL_CONTAINER="education-platform_mysql_1"
POSTGRES_CONTAINER="education-platform_postgres_1"
BACKUP_RETENTION_DAYS=14
DATE=$(date +%Y%m%d_%H%M%S)

# Création du répertoire de sauvegarde
mkdir -p ${BACKUP_DIR}/${DATE}

echo "Début de la sauvegarde - ${DATE}"

# Sauvegarde MySQL
echo "Sauvegarde de la base de données MySQL..."
docker exec ${MYSQL_CONTAINER} mysqldump -u root -p${MYSQL_ROOT_PASSWORD} --all-databases > ${BACKUP_DIR}/${DATE}/mysql_backup.sql

# Sauvegarde PostgreSQL
echo "Sauvegarde de la base de données PostgreSQL..."
docker exec ${POSTGRES_CONTAINER} pg_dumpall -U user > ${BACKUP_DIR}/${DATE}/postgres_backup.sql

# Sauvegarde des fichiers uploadés
echo "Sauvegarde des fichiers uploadés..."
cp -r /opt/education-platform/uploads ${BACKUP_DIR}/${DATE}/uploads

# Compression
echo "Compression des sauvegardes..."
tar -czf ${BACKUP_DIR}/backup_${DATE}.tar.gz -C ${BACKUP_DIR} ${DATE}

# Nettoyage des fichiers temporaires
rm -rf ${BACKUP_DIR}/${DATE}

# Suppression des anciennes sauvegardes
echo "Nettoyage des anciennes sauvegardes..."
find ${BACKUP_DIR} -name "backup_*.tar.gz" -type f -mtime +${BACKUP_RETENTION_DAYS} -delete

echo "Sauvegarde terminée"

# Synchronisation avec le stockage externe (optionnel)
if [ -n "${REMOTE_BACKUP_ENABLED}" ] && [ "${REMOTE_BACKUP_ENABLED}" = "true" ]; then
  echo "Synchronisation avec le stockage externe..."
  rclone sync ${BACKUP_DIR} remote:education-platform-backups
  echo "Synchronisation terminée"
fi
\end{lstlisting}

\section{Défis rencontrés et solutions apportées}

\subsection{Défis d'implémentation et solutions techniques}

Au cours du développement, nous avons rencontré plusieurs défis techniques spécifiques à l'implémentation des systèmes conçus :

\begin{itemize}
  \item \textbf{Parsing des documents complexes} : Les documents PDF avec des structures complexes (tableaux imbriqués, éléments flottants, annotations) posaient des problèmes d'extraction.
  
  \textit{Solution} : Développement d'un pipeline hybride combinant PyPDF2, pdf2image et Tesseract OCR pour les sections problématiques, avec une logique de détection automatique des zones nécessitant un traitement spécial.
  
  \begin{lstlisting}[style=codestyle, language=Python]
  # Extrait du code de traitement hybride
  def process_complex_document(pdf_path):
      basic_text = extract_text_with_pypdf(pdf_path)
      problematic_pages = detect_problematic_pages(basic_text)
      
      enhanced_text = basic_text.copy()
      for page_num in problematic_pages:
          # Conversion en image et OCR pour les pages problématiques
          page_image = convert_page_to_image(pdf_path, page_num)
          ocr_text = perform_ocr(page_image)
          enhanced_text[page_num] = ocr_text
          
      return merge_text_results(enhanced_text)
  \end{lstlisting}
  
  \item \textbf{Optimisation des prompts LLM} : Génération de prompts efficaces pour obtenir des réponses précises.
  
  \textit{Solution} : Développement d'un système de templates de prompts avec variables contextuelles et évaluation automatique de la qualité des réponses.
  
  \begin{lstlisting}[style=codestyle, language=Python]
  # Gestionnaire de templates de prompts
  class PromptTemplateManager:
      def __init__(self, templates_dir):
          self.templates = self._load_templates(templates_dir)
          self.metrics = PromptMetrics()
      
      def generate_prompt(self, template_name, context):
          template = self.templates.get(template_name)
          if not template:
              raise ValueError(f"Template '{template_name}' not found")
          
          # Injection du contexte dans le template
          prompt = template.format(**context)
          
          # Enregistrement pour analyse ultérieure
          prompt_id = self.metrics.register_prompt_use(template_name, context)
          
          return prompt, prompt_id
      
      def record_response_quality(self, prompt_id, quality_score, feedback=None):
          self.metrics.record_quality(prompt_id, quality_score, feedback)
          
          # Si le score est bas, déclencher une optimisation de template
          if quality_score < 0.6:
              self._trigger_template_optimization(prompt_id)
  \end{lstlisting}
  
  \item \textbf{Performances des interfaces riches} : Ralentissements lors du chargement de grandes quantités de données dans l'interface utilisateur.
  
  \textit{Solution} : Implémentation de techniques de virtualisation et de pagination infinie pour les listes et tableaux.
  
  \begin{lstlisting}[style=codestyle, language=JavaScript]
  // Composant de tableau virtualisé avec pagination infinie
  const VirtualizedTable = ({ fetchItems, columns, rowHeight = 40 }) => {
    const [items, setItems] = useState([]);
    const [page, setPage] = useState(0);
    const [loading, setLoading] = useState(false);
    const [hasMore, setHasMore] = useState(true);
    const containerRef = useRef(null);
    
    const loadMoreItems = useCallback(async () => {
      if (loading || !hasMore) return;
      
      setLoading(true);
      try {
        const newItems = await fetchItems(page);
        if (newItems.length === 0) {
          setHasMore(false);
        } else {
          setItems(prev => [...prev, ...newItems]);
          setPage(prev => prev + 1);
        }
      } finally {
        setLoading(false);
      }
    }, [fetchItems, page, loading, hasMore]);
    
    // Observer pour détecter la fin de la liste
    useEffect(() => {
      const observer = new IntersectionObserver(
        entries => {
          if (entries[0].isIntersecting && hasMore) loadMoreItems();
        },
        { threshold: 0.5 }
      );
      
      if (containerRef.current) observer.observe(containerRef.current);
      return () => observer.disconnect();
    }, [loadMoreItems, hasMore]);
    
    // Rendu du composant - simplifié pour concision
    return (
      <div className="virtualized-table-container">
        {/* En-tête et corps du tableau omis pour concision */}
        {hasMore && (
          <div ref={containerRef} className="loading-indicator">
            {loading ? 'Chargement...' : 'Charger plus'}
          </div>
        )}
      </div>
    );
  };
  \end{lstlisting}
  
  \item \textbf{Synchronisation mobile-web} : Cohérence des données entre applications web et mobiles, notamment en mode hors-ligne.
  
  \textit{Solution} : Mise en œuvre d'un système de synchronisation basé sur des files d'attente locales et des identifiants temporaires.
  
  \begin{lstlisting}[style=codestyle, language=JavaScript]
  // Service de synchronisation pour React Native
  class SyncService {
    constructor(apiClient, storage) {
      this.apiClient = apiClient;
      this.storage = storage;
      this.syncQueue = [];
      this.isSyncing = false;
      this.networkStatus = { isConnected: false };
      
      // Initialisation
      this.init();
    }
    
    async init() {
      // Charger la file d'attente depuis le stockage local
      const savedQueue = await this.storage.getItem('syncQueue');
      if (savedQueue) this.syncQueue = JSON.parse(savedQueue);
      
      // Écouter les changements de connectivité
      NetInfo.addEventListener(state => {
        const wasConnected = this.networkStatus.isConnected;
        this.networkStatus.isConnected = state.isConnected;
        
        // Si connexion récupérée, lancer la synchronisation
        if (!wasConnected && state.isConnected) this.attemptSync();
      });
    }
    
    // Ajouter une opération à la file d'attente
    async queueOperation(operation) {
      // Générer un ID temporaire si nécessaire
      if (operation.type === 'create') operation.data._tempId = uuid.v4();
      
      // Ajouter à la file et persister
      this.syncQueue.push({
        id: uuid.v4(),
        timestamp: Date.now(),
        operation,
        status: 'pending'
      });
      
      await this.storage.setItem('syncQueue', JSON.stringify(this.syncQueue));
      
      // Synchroniser si en ligne
      if (this.networkStatus.isConnected) this.attemptSync();
      
      return operation.type === 'create' ? operation.data._tempId : null;
    }
    
    // Méthodes de traitement omises pour concision
  }
  \end{lstlisting}
  
  \item \textbf{Sécurité des données sensibles} : Protection des informations personnelles et académiques.
  
  \textit{Solution} : Implémentation d'un système de chiffrement à plusieurs niveaux, incluant le chiffrement des données au repos et en transit.
  
  \begin{lstlisting}[style=codestyle, language=JavaScript]
  // Service de chiffrement pour les données sensibles
  class EncryptionService {
    constructor(encryptionKey) {
      this.encryptionKey = encryptionKey;
      this.algorithm = 'aes-256-gcm';
    }
    
    // Chiffrer des données sensibles
    encrypt(data) {
      // Générer un vecteur d'initialisation aléatoire
      const iv = crypto.randomBytes(16);
      
      // Créer le chiffreur avec la clé et l'IV
      const cipher = crypto.createCipheriv(this.algorithm, this.encryptionKey, iv);
      
      // Chiffrer les données
      let encrypted = cipher.update(JSON.stringify(data), 'utf8', 'hex');
      encrypted += cipher.final('hex');
      
      // Récupérer le tag d'authentification
      const authTag = cipher.getAuthTag();
      
      // Retourner les données chiffrées avec l'IV et le tag d'authentification
      return {
        iv: iv.toString('hex'),
        encrypted,
        authTag: authTag.toString('hex')
      };
    }
    
    // Déchiffrer des données
    decrypt(encryptedData) {
      const { iv, encrypted, authTag } = encryptedData;
      
      // Créer le déchiffreur
      const decipher = crypto.createDecipheriv(
        this.algorithm,
        this.encryptionKey,
        Buffer.from(iv, 'hex')
      );
      
      // Définir le tag d'authentification
      decipher.setAuthTag(Buffer.from(authTag, 'hex'));
      
      // Déchiffrer
      let decrypted = decipher.update(encrypted, 'hex', 'utf8');
      decrypted += decipher.final('utf8');
      
      // Parser les données JSON
      return JSON.parse(decrypted);
    }
  }
  \end{lstlisting}
\end{itemize}

\subsection{Défis d'utilisabilité et solutions UX}

Plusieurs défis liés à l'expérience utilisateur ont également été adressés :

\begin{itemize}
  \item \textbf{Complexité de l'interface de création de profils IA} : Les utilisateurs trouvaient le processus intimidant.
  
  \textit{Solution} : Refonte de l'interface avec une approche par étapes, incluant des guides contextuels et des exemples interactifs.
  
  \item \textbf{Confusion sur la pertinence des réponses IA} : Les utilisateurs avaient du mal à comprendre d'où venaient les informations.
  
  \textit{Solution} : Implémentation d'un système de citation des sources avec mise en évidence des passages pertinents et affichage du niveau de confiance.
  
  \item \textbf{Difficulté d'utilisation sur appareils mobiles} : Certaines fonctionnalités étaient difficiles à utiliser sur petit écran.
  
  \textit{Solution} : Développement d'interfaces adaptatives avec des contrôles repensés pour l'interaction tactile et introduction de gestes pour les actions courantes.
\end{itemize}

\subsection{Défis d'intégration et solutions techniques}

L'intégration des deux systèmes a présenté ses propres défis techniques :

\begin{itemize}
  \item \textbf{Conflits de sessions entre les systèmes} : Les jetons d'authentification n'étaient pas correctement partagés.
  
  \textit{Solution} : Développement d'un middleware d'authentification partagé qui maintient la cohérence des sessions et gère la translation des contextes utilisateur.
  
  \item \textbf{Latence lors des requêtes inter-systèmes} : Les requêtes synchrones entre les systèmes créaient des problèmes de performance.
  
  \textit{Solution} : Mise en place d'un système de communication asynchrone basé sur des événements et un cache partagé avec Redis.
  
  \begin{lstlisting}[style=codestyle, language=JavaScript]
  // Service d'événements inter-systèmes
  class IntegrationEventService {
    constructor(redisClient) {
      this.redis = redisClient;
      this.eventHandlers = {};
      
      // S'abonner aux canaux d'événements
      this.redis.subscribe('school-system-events');
      this.redis.subscribe('ai-profiles-events');
      
      // Configurer le gestionnaire de messages
      this.redis.on('message', (channel, message) => {
        try {
          const event = JSON.parse(message);
          this.processEvent(channel, event);
        } catch (error) {
          console.error(`Error processing event from ${channel}:`, error);
        }
      });
    }
    
    // Publier un événement
    async publishEvent(channel, eventType, payload) {
      const event = {
        id: uuid.v4(),
        type: eventType,
        timestamp: Date.now(),
        payload
      };
      
      await this.redis.publish(channel, JSON.stringify(event));
      return event.id;
    }
    
    // S'abonner à un type d'événement
    on(eventType, handler) {
      if (!this.eventHandlers[eventType]) {
        this.eventHandlers[eventType] = [];
      }
      
      this.eventHandlers[eventType].push(handler);
    }
    
    // Traiter un événement reçu
    processEvent(channel, event) {
      const handlers = this.eventHandlers[event.type] || [];
      
      for (const handler of handlers) {
        try {
          handler(event.payload, event);
        } catch (error) {
          console.error(`Error in handler for event ${event.type}:`, error);
        }
      }
    }
  }
  \end{lstlisting}
\end{itemize}

\section{Pages d'accueil et de présentation}

Les pages d'accueil et de présentation de nos systèmes ont été conçues pour être intuitives, informatives et visuellement attrayantes. Ces pages servent de point d'entrée pour les utilisateurs et présentent les principales fonctionnalités des plateformes.

\subsection{Page d'accueil du système de gestion scolaire}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/landing/hero.png}
  \caption{\textbf{Section d'accueil (Hero)} du système de gestion scolaire présentant l'offre principale.}
  \label{fig:landing_hero}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/landing/info.png}
  \caption{\textbf{Section d'information} détaillant les caractéristiques clés de la plateforme.}
  \label{fig:landing_info}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/landing/stats.png}
  \caption{\textbf{Section de statistiques} mettant en avant les résultats et l'impact du système.}
  \label{fig:landing_stats}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/landing/Screenshot 2025-06-09 at 23-12-47 Vite React TS.png}
  \caption{\textbf{Section de tarification} présentant les différentes options d'abonnement.}
  \label{fig:landing_pricing}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/landing/Screenshot 2025-06-09 at 23-12-17 Vite React TS.png}
  \caption{\textbf{Section des fonctionnalités} du système de gestion scolaire.}
  \label{fig:landing_features}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/landing/contact.png}
  \caption{\textbf{Section de contact} avec formulaire permettant aux utilisateurs de demander des informations.}
  \label{fig:landing_contact}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth,keepaspectratio]{pfe-pics/landing/fotter.png}
  \caption{\textbf{Pied de page (Footer)} contenant les liens importants et informations légales.}
  \label{fig:landing_footer}
\end{figure}

\subsection{Pages de présentation du système de gestion scolaire}

Les composants de la page d'accueil et de présentation du système de gestion scolaire travaillent ensemble pour offrir une expérience utilisateur cohérente et informative, guidant les visiteurs depuis la découverte initiale jusqu'à la prise de contact ou l'inscription.

\section{Environnement de développement personnel}

Pour le développement de ces deux systèmes complémentaires, un environnement de développement personnel optimisé a été configuré, permettant une productivité maximale et une expérience de développement fluide.

\subsection{Système d'exploitation et outils principaux}

\begin{itemize}
  \item \textbf{Système d'exploitation} : Arch Linux, choisi pour sa flexibilité, sa légèreté et sa capacité de personnalisation avancée
  
  \item \textbf{Éditeur de code principal} : Neovim avec une configuration personnalisée incluant des plugins pour le développement web, Python et TypeScript
  
  \item \textbf{Éditeur secondaire} : VSCodium (version open-source de VS Code), utilisé principalement pour le débogage et les fonctionnalités d'édition collaboratives
  
  \item \textbf{Terminal} : Alacritty avec configuration tmux pour la gestion efficace des sessions multiples
  
  \item \textbf{Shell} : Zsh avec le framework Oh My Zsh et des plugins pour Git, Docker et Node.js
\end{itemize}

\subsection{Environnement de base de données}

\begin{itemize}
  \item \textbf{MySQL} : Utilisé comme système de gestion de base de données relationnelle principal pour le système de gestion scolaire
  
  \item \textbf{XAMPP} : Suite de développement local intégrant Apache, MariaDB et PHP pour le développement rapide
  
  \item \textbf{PostgreSQL} : Utilisé pour le système de création de profils IA
  
  \item \textbf{MongoDB} : Utilisé pour certaines fonctionnalités spécifiques nécessitant une structure de données plus flexible
  
  \item \textbf{Redis} : Utilisé pour la mise en cache et la gestion des sessions
\end{itemize}

\subsection{Outils de développement frontend}

\begin{itemize}
  \item \textbf{Node.js} et \textbf{npm} : Pour la gestion des dépendances et l'exécution des scripts
  
  \item \textbf{Vite} : Comme outil de build rapide pour le développement frontend
  
  \item \textbf{React Developer Tools} : Pour le débogage des composants React
  
  \item \textbf{TypeScript} : Pour un développement typé et plus robuste
  
  \item \textbf{ESLint} et \textbf{Prettier} : Pour le linting et le formatage automatique du code
\end{itemize}

\subsection{Outils de développement backend}

\begin{itemize}
  \item \textbf{Postman} : Pour tester et documenter les API
  
  \item \textbf{Python avec pyenv} : Pour la gestion de plusieurs versions de Python
  
  \item \textbf{Docker} et \textbf{Docker Compose} : Pour la conteneurisation des services
  
  \item \textbf{Swagger UI} : Pour la documentation interactive des API
\end{itemize}

\section{Glossaire des abréviations}

\begin{itemize}
  \item \textbf{API} : Application Programming Interface - Interface de programmation d'application permettant la communication entre différents logiciels
  
  \item \textbf{CSS} : Cascading Style Sheets - Langage de feuille de style utilisé pour décrire la présentation d'un document écrit en HTML
  
  \item \textbf{CRUD} : Create, Read, Update, Delete - Opérations de base pour la persistance des données
  
  \item \textbf{DOM} : Document Object Model - Interface de programmation pour les documents HTML et XML
  
  \item \textbf{IA} : Intelligence Artificielle - Ensemble des théories et techniques développant des programmes informatiques complexes capables de simuler certains traits de l'intelligence humaine
  
  \item \textbf{JWT} : JSON Web Token - Standard ouvert basé sur JSON pour créer des jetons d'accès
  
  \item \textbf{LLM} : Large Language Model - Modèle de langage de grande taille utilisé pour générer et comprendre le langage naturel
  
  \item \textbf{ORM} : Object-Relational Mapping - Technique de programmation informatique qui crée une couche d'abstraction entre la base de données relationnelle et le modèle objet
  
  \item \textbf{REST} : Representational State Transfer - Style d'architecture pour les systèmes distribués
  
  \item \textbf{SSO} : Single Sign-On - Méthode permettant à un utilisateur d'accéder à plusieurs applications avec un seul identifiant
  
  \item \textbf{UI} : User Interface - Interface utilisateur, partie visible d'une application avec laquelle interagit l'utilisateur
  
  \item \textbf{UX} : User Experience - Expérience utilisateur, ensemble des interactions et expériences vécues par l'utilisateur
  
  \item \textbf{WSGI} : Web Server Gateway Interface - Spécification simple et universelle pour l'interface entre les serveurs web et les applications web pour Python
  
  \item \textbf{XAMPP} : Cross-Platform (X), Apache, MariaDB, PHP, Perl - Suite logicielle constituant un environnement de développement web
\end{itemize}

\section{Conclusion de la réalisation}

Au terme de ce chapitre consacré à la réalisation et à la mise en œuvre de nos deux systèmes complémentaires, nous pouvons constater que les objectifs fixés dans le cahier des charges ont été atteints avec succès. L'implémentation du système de gestion scolaire et de la plateforme de création de profils IA a abouti à des solutions fonctionnelles, performantes et adaptées aux besoins des différents utilisateurs.

Les choix technologiques effectués, notamment l'utilisation de React et TypeScript pour le frontend, Node.js/Express et FastAPI pour le backend, ainsi que MySQL et PostgreSQL pour la persistance des données, se sont révélés pertinents et ont permis de développer des systèmes robustes et évolutifs.

Les interfaces utilisateur développées pour chaque type d'utilisateur (administrateur, enseignant, étudiant, parent) offrent une expérience intuitive et adaptée aux besoins spécifiques de chacun. De même, la plateforme de création de profils IA propose une interface ergonomique pour la gestion des documents et des conversations avec les assistants virtuels.

Les défis techniques rencontrés, notamment dans le traitement des documents, l'optimisation des performances et l'intégration des deux systèmes, ont été surmontés grâce à des solutions innovantes et une approche méthodique du développement.

Cette phase de réalisation a également été l'occasion de mettre en pratique les bonnes pratiques de développement logiciel, comme le versionnement du code, les tests automatisés et le déploiement continu, garantissant ainsi la qualité et la maintenabilité des solutions développées.

Les systèmes ainsi implémentés constituent une base solide pour les évolutions futures et répondent pleinement aux objectifs initiaux de modernisation de l'environnement éducatif à travers la gestion administrative et l'assistance intelligente.
